% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{spscicomp Documentation}
\date{January 15, 2015}
\release{beta}
\author{The Project Group}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Common modules}
\label{common:welcome-to-spscicomp-s-documentation}\label{common::doc}\label{common:common-modules}
Currently there is one common module for all algorithms, namely the data importer module. It provides the following classes for importing numerical data:


\section{common\_data\_importer}
\label{common:common-data-importer}\label{common:module-common_data_importer}\index{common\_data\_importer (module)}\index{CommonBinaryFileDataImporter (class in common\_data\_importer)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonBinaryFileDataImporter}\pysiglinewithargsret{\strong{class }\code{common\_data\_importer.}\bfcode{CommonBinaryFileDataImporter}}{\emph{filename}}{}
Import data from a binary file. The file format should be as generated by \code{numpy.save()}.
\index{get\_data() (common\_data\_importer.CommonBinaryFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonBinaryFileDataImporter.get_data}\pysiglinewithargsret{\bfcode{get\_data}}{\emph{size}}{}
Return a numpy array of floats where each data point occupies one row of the array. The data is read from
the current position of the pointer onwards. If the pointer reaches the end of the file, an array of all data
points up to the end of the file is returned and the hasMoreData flag is set to False.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{size} (\emph{int}) -- Number of data points to be returned.

\item[{Returns}] \leavevmode
A numpy array of data points.

\item[{Return type}] \leavevmode
numpy.array

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_more\_data() (common\_data\_importer.CommonBinaryFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonBinaryFileDataImporter.has_more_data}\pysiglinewithargsret{\bfcode{has\_more\_data}}{}{}
Test if the pointer is at the end of the file or not.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if there is more data after the pointer, and False if not.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_file\_input\_stream() (common\_data\_importer.CommonBinaryFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonBinaryFileDataImporter.init_file_input_stream}\pysiglinewithargsret{\bfcode{init\_file\_input\_stream}}{}{}
Create a numpy array object which reads from the binary file using a memmap.

\end{fulllineitems}

\index{rewind() (common\_data\_importer.CommonBinaryFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonBinaryFileDataImporter.rewind}\pysiglinewithargsret{\bfcode{rewind}}{}{}
Reset the file pointer to the beginning and set the hasMoreData flag to True.

\end{fulllineitems}


\end{fulllineitems}

\index{CommonDataImporter (class in common\_data\_importer)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonDataImporter}\pysigline{\strong{class }\code{common\_data\_importer.}\bfcode{CommonDataImporter}}
This is an abstract data importer class. Implementations are expected to override the get\_data and has\_more\_data
methods.

\end{fulllineitems}

\index{CommonFileDataImporter (class in common\_data\_importer)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonFileDataImporter}\pysiglinewithargsret{\strong{class }\code{common\_data\_importer.}\bfcode{CommonFileDataImporter}}{\emph{filename}}{}
Import data from a text file. The data structure should be as follows:
One point occupies one line.
Each point consists of several floats with space as a separator.
\index{close\_file() (common\_data\_importer.CommonFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonFileDataImporter.close_file}\pysiglinewithargsret{\bfcode{close\_file}}{}{}
Close the file handle if it is open.

\end{fulllineitems}

\index{get\_data() (common\_data\_importer.CommonFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonFileDataImporter.get_data}\pysiglinewithargsret{\bfcode{get\_data}}{\emph{size}}{}
Return a numpy array of floats where each data point occupies one row of the array. The data is read from
the current position of the pointer onwards. If the pointer reaches the end of the file, an array of all data
points up to the end of the file is returned, the file is closed and the hasMoreData flag is set to False.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{size} (\emph{int}) -- Number of data points to be returned.

\item[{Returns}] \leavevmode
A numpy array of data points.

\item[{Return type}] \leavevmode
numpy.array

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_more\_data() (common\_data\_importer.CommonFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonFileDataImporter.has_more_data}\pysiglinewithargsret{\bfcode{has\_more\_data}}{}{}
Test if the pointer is at the end of the file or not.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if there is more data after the pointer, and False if not.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_file\_input\_stream() (common\_data\_importer.CommonFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonFileDataImporter.init_file_input_stream}\pysiglinewithargsret{\bfcode{init\_file\_input\_stream}}{}{}
Initialize the file input stream, that is, open the file and create the iterator on the file's lines.

\end{fulllineitems}

\index{rewind() (common\_data\_importer.CommonFileDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonFileDataImporter.rewind}\pysiglinewithargsret{\bfcode{rewind}}{}{}
Reset the file pointer to the beginning, that is, initialize the file and set the hasMoreData flag to True.

\end{fulllineitems}


\end{fulllineitems}

\index{CommonSimpleDataImporter (class in common\_data\_importer)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonSimpleDataImporter}\pysiglinewithargsret{\strong{class }\code{common\_data\_importer.}\bfcode{CommonSimpleDataImporter}}{\emph{data}}{}
``Import'' data from a given data array.
\index{get\_data() (common\_data\_importer.CommonSimpleDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonSimpleDataImporter.get_data}\pysiglinewithargsret{\bfcode{get\_data}}{\emph{size}}{}
Return all available data regardless of the requested size.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{size} (\emph{int}) -- Size of data which is to be returned. This parameter is disregarded as all data is returned.

\item[{Returns}] \leavevmode
All data.

\item[{Return type}] \leavevmode
numpy.array

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_more\_data() (common\_data\_importer.CommonSimpleDataImporter method)}

\begin{fulllineitems}
\phantomsection\label{common:common_data_importer.CommonSimpleDataImporter.has_more_data}\pysiglinewithargsret{\bfcode{has\_more\_data}}{}{}
Return if there is any more data. As all data is returned when using get\_data, this function always returns
False.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
False since there never is any more data.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{The k-means algorithm}
\label{kmeans::doc}\label{kmeans:the-k-means-algorithm}
The implementation of the k-means algorithm consists of the following modules:


\section{kmeans\_main}
\label{kmeans:module-kmeans_main}\label{kmeans:kmeans-main}\index{kmeans\_main (module)}\index{kmeans() (in module kmeans\_main)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans_main.kmeans}\pysiglinewithargsret{\code{kmeans\_main.}\bfcode{kmeans}}{\emph{k}, \emph{importer=None}}{}
Initialize and run the k-means algorithm. If any of the optimized implementations (CUDA, OpenCL, C extension) are
available, they are selected and initialized automatically in the above order. Then the respective
\code{kmeans.Kmeans.calculate\_centers()} method is called and the output is returned.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{k} (\emph{int}) -- Number of cluster centers to compute.

\item {} 
\textbf{importer} ({\hyperref[common:common_data_importer.CommonDataImporter]{\code{CommonDataImporter}}}) -- A {\hyperref[common:common_data_importer.CommonDataImporter]{\code{CommonDataImporter}}} object to be used for importing the numerical data.

\end{itemize}

\item[{Returns}] \leavevmode
An array of integers \([c(x_i)]\) where \(x_i\) is the i-th data point and
\(c(x_i)\) is the index of the cluster center to which \(x_i\) belongs.

\item[{Return type}] \leavevmode
int{[}{]}

\end{description}\end{quote}

\end{fulllineitems}



\section{kmeans}
\label{kmeans:module-kmeans}\label{kmeans:kmeans}\index{kmeans (module)}\index{DefaultKmeans (class in kmeans)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans.DefaultKmeans}\pysiglinewithargsret{\strong{class }\code{kmeans.}\bfcode{DefaultKmeans}}{\emph{metric=\textless{}kmeans\_metric.EuclideanMetric object at 0x7f1901016750\textgreater{}}, \emph{importer=None}, \emph{chunk\_size=1000}, \emph{max\_steps=100}}{}
Default implementation of the k-means algorithm. Once supplied with an {\hyperref[common:common_data_importer.CommonDataImporter]{\code{CommonDataImporter}}} object, use the
calculate\_centers method to compute k cluster centers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{metric} (\code{KmeansMetric}) -- A \code{KmeansMetric} object to be used for calculating distances between points. The default is
the \code{EuclideanMetric}.

\item {} 
\textbf{importer} ({\hyperref[common:common_data_importer.CommonDataImporter]{\code{CommonDataImporter}}}) -- A {\hyperref[common:common_data_importer.CommonDataImporter]{\code{CommonDataImporter}}} object to be used for importing the numerical data.

\item {} 
\textbf{chunk\_size} (\emph{int}) -- The number of data points to be imported and processed at a time.

\item {} 
\textbf{max\_steps} (\emph{int}) -- The maximum number of steps to run the algorithm for. If the iteration did not converge after
this number of steps, the algorithm is terminated and the last result returned.

\end{itemize}

\end{description}\end{quote}
\index{calculate\_centers() (kmeans.DefaultKmeans method)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans.DefaultKmeans.calculate_centers}\pysiglinewithargsret{\bfcode{calculate\_centers}}{\emph{k}, \emph{initial\_centers=None}, \emph{return\_centers=False}, \emph{save\_history=False}}{}
Main method of the k-means algorithm. Computes k cluster centers from the data supplied by a
{\hyperref[common:common_data_importer.CommonDataImporter]{\code{CommonDataImporter}}} object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{k} (\emph{int}) -- Number of cluster centers to compute.

\item {} 
\textbf{initial\_centers} (\emph{numpy.array}) -- Array of cluster centers to start the iteration with. If omitted, random data points
from the first chunk of data are used.

\item {} 
\textbf{return\_centers} (\emph{bool}) -- If set to True then the cluster centers are returned.

\item {} 
\textbf{save\_history} (\emph{bool}) -- If this and return\_centers is set to True then the cluster centers in each iteration step
are returned.

\end{itemize}

\item[{Returns}] \leavevmode
An array of integers \([c(x_i)]\) where \(x_i\) is the i-th data point and
\(c(x_i)\) is the index of the cluster center to which \(x_i\) belongs.

\item[{Return type}] \leavevmode
int{[}{]}

\item[{Returns}] \leavevmode
An array of the computed cluster centers.

\item[{Return type}] \leavevmode
np.array

\item[{Returns}] \leavevmode
A list of arrays of the cluster centers in each iteration step.

\item[{Return type}] \leavevmode
np.array{[}{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Kmeans (class in kmeans)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans.Kmeans}\pysiglinewithargsret{\strong{class }\code{kmeans.}\bfcode{Kmeans}}{\emph{metric=\textless{}kmeans\_metric.EuclideanMetric object at 0x7f1901016290\textgreater{}}, \emph{importer=None}}{}
Abstract k-means algorithm. Implementations are expected to override the calculate\_centers method.

\end{fulllineitems}



\section{c\_kmeans}
\label{kmeans:module-extension.c_kmeans}\label{kmeans:c-kmeans}\index{extension.c\_kmeans (module)}\index{CKmeans (class in extension.c\_kmeans)}

\begin{fulllineitems}
\phantomsection\label{kmeans:extension.c_kmeans.CKmeans}\pysiglinewithargsret{\strong{class }\code{extension.c\_kmeans.}\bfcode{CKmeans}}{\emph{metric=\textless{}kmeans\_metric.EuclideanMetric object at 0x7f1900f60290\textgreater{}}, \emph{importer=None}, \emph{chunk\_size=1000}, \emph{max\_steps=100}}{}
An implementation of the k-means algorithm in C. Refer to the {\hyperref[kmeans:kmeans.DefaultKmeans]{\code{DefaultKmeans}}} class for parameters and
public methods.

\end{fulllineitems}



\section{cuda\_kmeans}
\label{kmeans:cuda-kmeans}\index{cuda.cuda\_kmeans.CUDAKmeans (class in extension.c\_kmeans)}

\begin{fulllineitems}
\phantomsection\label{kmeans:extension.c_kmeans.cuda.cuda_kmeans.CUDAKmeans}\pysiglinewithargsret{\strong{class }\code{cuda.cuda\_kmeans.}\bfcode{CUDAKmeans}}{\emph{metric=EuclideanMetric()}, \emph{importer=None}, \emph{chunk\_size=1000}, \emph{max\_steps=100}}{}
An implementation of the k-means algorithm in CUDA. Refer to the {\hyperref[kmeans:kmeans.DefaultKmeans]{\code{DefaultKmeans}}} class for parameters and
public methods.

\end{fulllineitems}



\section{opencl\_kmeans}
\label{kmeans:opencl-kmeans}\index{opencl.opencl\_kmeans.OpenCLKmeans (class in extension.c\_kmeans)}

\begin{fulllineitems}
\phantomsection\label{kmeans:extension.c_kmeans.opencl.opencl_kmeans.OpenCLKmeans}\pysiglinewithargsret{\strong{class }\code{opencl.opencl\_kmeans.}\bfcode{OpenCLKmeans}}{\emph{metric=EuclideanMetric()}, \emph{importer=None}, \emph{chunk\_size=1000}, \emph{max\_steps=100}}{}
An implementation of the k-means algorithm in OpenCL. Refer to the {\hyperref[kmeans:kmeans.DefaultKmeans]{\code{DefaultKmeans}}} class for parameters and
public methods.

\end{fulllineitems}



\section{kmeans\_data\_generator}
\label{kmeans:module-kmeans_data_generator}\label{kmeans:kmeans-data-generator}\index{kmeans\_data\_generator (module)}\index{KmeansDataGenerator (class in kmeans\_data\_generator)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans_data_generator.KmeansDataGenerator}\pysigline{\strong{class }\code{kmeans\_data\_generator.}\bfcode{KmeansDataGenerator}}
Abstract data generator. Implementations are expected to override the generate\_data method.

\end{fulllineitems}

\index{KmeansRandomDataGenerator (class in kmeans\_data\_generator)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans_data_generator.KmeansRandomDataGenerator}\pysiglinewithargsret{\strong{class }\code{kmeans\_data\_generator.}\bfcode{KmeansRandomDataGenerator}}{\emph{size}, \emph{dimension}, \emph{centers\_count}}{}
Generate a test dataset for the k-means algorithm. The centers are generated uniformly.
The other points are produced randomly near one of the centers with normal distribution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{size} (\emph{int}) -- Number of data points to generate.

\item {} 
\textbf{dimension} (\emph{int}) -- Dimension of the euclidean space the data points will belong to.

\item {} 
\textbf{centers\_count} (\emph{int}) -- Number of cluster centers around which the data points are to be generated.

\end{itemize}

\end{description}\end{quote}
\index{get\_centers() (kmeans\_data\_generator.KmeansRandomDataGenerator method)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans_data_generator.KmeansRandomDataGenerator.get_centers}\pysiglinewithargsret{\bfcode{get\_centers}}{}{}
Return the generated cluster centers.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A list of numpy arrays representing the cluster centers.

\item[{Return type}] \leavevmode
np.array{[}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_data() (kmeans\_data\_generator.KmeansRandomDataGenerator method)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans_data_generator.KmeansRandomDataGenerator.get_data}\pysiglinewithargsret{\bfcode{get\_data}}{}{}
Return the generated data points.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A numpy array of size \emph{size*x*dimension}.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_binary\_file() (kmeans\_data\_generator.KmeansRandomDataGenerator method)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans_data_generator.KmeansRandomDataGenerator.to_binary_file}\pysiglinewithargsret{\bfcode{to\_binary\_file}}{\emph{filename}}{}
Save the generated data to a binary file using \code{numpy.save()} which can be read later using the
respective {\hyperref[common:common_data_importer.CommonDataImporter]{\code{CommonDataImporter}}} object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) -- The file name.

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_file() (kmeans\_data\_generator.KmeansRandomDataGenerator method)}

\begin{fulllineitems}
\phantomsection\label{kmeans:kmeans_data_generator.KmeansRandomDataGenerator.to_file}\pysiglinewithargsret{\bfcode{to\_file}}{\emph{filename}}{}
Save the generated data to a text file using \code{numpy.savetxt()} which can be read later using the
respective {\hyperref[common:common_data_importer.CommonDataImporter]{\code{CommonDataImporter}}} object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) -- The file name.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\texttt{common\_data\_importer}}, \pageref{common:module-common_data_importer}
\indexspace
\bigletter{e}
\item {\texttt{extension.c\_kmeans}}, \pageref{kmeans:module-extension.c_kmeans}
\indexspace
\bigletter{k}
\item {\texttt{kmeans}}, \pageref{kmeans:module-kmeans}
\item {\texttt{kmeans\_data\_generator}}, \pageref{kmeans:module-kmeans_data_generator}
\item {\texttt{kmeans\_main}}, \pageref{kmeans:module-kmeans_main}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
